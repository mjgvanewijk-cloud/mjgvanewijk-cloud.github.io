<!doctype html>
<html lang="nl">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
  <title>FinFlow Testcode Generator (C2)</title>
  <style>
    body{font-family: -apple-system, system-ui, Segoe UI, Roboto, Arial; padding:20px; max-width: 760px; margin:0 auto;}
    input, textarea, button{font-size:16px; padding:10px;}
    .row{display:flex; gap:12px; flex-wrap:wrap;}
    .col{flex:1 1 260px;}
    textarea{width:100%; height:120px;}
    button{cursor:pointer;}
    .hint{opacity:.75; font-size:13px;}
    .code{font-family: ui-monospace, SFMono-Regular, Menlo, monospace;}
  </style>
</head>
<body>
  <h2>FinFlow Testcode Generator (C2)</h2>
  <p class="hint">Open dit bestand lokaal op jouw laptop. Upload dit bestand niet naar GitHub (anders kan iedereen testcodes maken).</p>

  <div class="row">
    <div class="col">
      <label>Dagen geldig</label<br/>
      <input id="days" type="number" value="30" min="1" max="365"/>
    </div>
    <div class="col">
      <label>Notitie (optioneel)</label><br/>
      <input id="note" type="text" placeholder="Tester naam / batch"/>
    </div>
    <div class="col">
      <label>Activatie-ID (van tester)</label><br/>
      <input id="deviceId" type="text" placeholder="Plak de Activatie-ID hier"/>
      <div class="hint">De gegenereerde code werkt alleen op dit toestel.</div>
    </div>
  </div>

  <p></p>
  <button id="gen">Genereer testcode</button>

  <p></p>
  <label>Testcode</label>
  <textarea id="out" class="code" readonly></textarea>

  <script type="module">
    const SECRET = "FF_TEST_SECRET_V1_CHANGE_ME";
    function base64UrlEncode(str) {
      const b64 = btoa(unescape(encodeURIComponent(str)));
      return b64.replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,'');
    }
    async function hmacSha256Base64Url(messageB64Url) {
  // Prefer WebCrypto when available (secure contexts), otherwise fall back to a pure-JS implementation.
  try {
    if (typeof crypto !== "undefined" && crypto.subtle) {
      const enc = new TextEncoder();
      const key = await crypto.subtle.importKey(
        "raw",
        enc.encode(SECRET),
        { name: "HMAC", hash: "SHA-256" },
        false,
        ["sign","verify"]
      );
      const sig = await crypto.subtle.sign("HMAC", key, enc.encode(messageB64Url));
      const bytes = new Uint8Array(sig);
      let binary = "";
      for (let i=0;i<bytes.length;i++) binary += String.fromCharCode(bytes[i]);
      return btoa(binary).replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,'');
    }
  } catch (e) {
    // fall through to JS implementation
  }

  // --- Pure JS SHA-256 + HMAC (works on http:// IP / file:// where WebCrypto may be unavailable) ---
  const enc = new TextEncoder();
  const keyBytes = enc.encode(SECRET);
  const msgBytes = enc.encode(messageB64Url);

  function rotr(n, x) { return (x >>> n) | (x << (32 - n)); }

  function sha256(bytes) {
    const K = new Uint32Array([
      0x428a2f98,0x71374491,0xb5c0fbcf,0xe9b5dba5,0x3956c25b,0x59f111f1,0x923f82a4,0xab1c5ed5,
      0xd807aa98,0x12835b01,0x243185be,0x550c7dc3,0x72be5d74,0x80deb1fe,0x9bdc06a7,0xc19bf174,
      0xe49b69c1,0xefbe4786,0x0fc19dc6,0x240ca1cc,0x2de92c6f,0x4a7484aa,0x5cb0a9dc,0x76f988da,
      0x983e5152,0xa831c66d,0xb00327c8,0xbf597fc7,0xc6e00bf3,0xd5a79147,0x06ca6351,0x14292967,
      0x27b70a85,0x2e1b2138,0x4d2c6dfc,0x53380d13,0x650a7354,0x766a0abb,0x81c2c92e,0x92722c85,
      0xa2bfe8a1,0xa81a664b,0xc24b8b70,0xc76c51a3,0xd192e819,0xd6990624,0xf40e3585,0x106aa070,
      0x19a4c116,0x1e376c08,0x2748774c,0x34b0bcb5,0x391c0cb3,0x4ed8aa4a,0x5b9cca4f,0x682e6ff3,
      0x748f82ee,0x78a5636f,0x84c87814,0x8cc70208,0x90befffa,0xa4506ceb,0xbef9a3f7,0xc67178f2
    ]);

    const H = new Uint32Array([
      0x6a09e667,0xbb67ae85,0x3c6ef372,0xa54ff53a,
      0x510e527f,0x9b05688c,0x1f83d9ab,0x5be0cd19
    ]);

    const l = bytes.length;
    const bitLenHi = Math.floor((l * 8) / 0x100000000);
    const bitLenLo = (l * 8) >>> 0;

    // pad
    const withOne = new Uint8Array(l + 1);
    withOne.set(bytes, 0);
    withOne[l] = 0x80;

    let paddedLen = withOne.length;
    while ((paddedLen % 64) !== 56) paddedLen++;
    const padded = new Uint8Array(paddedLen + 8);
    padded.set(withOne, 0);

    // length big-endian
    padded[paddedLen + 0] = (bitLenHi >>> 24) & 0xff;
    padded[paddedLen + 1] = (bitLenHi >>> 16) & 0xff;
    padded[paddedLen + 2] = (bitLenHi >>>  8) & 0xff;
    padded[paddedLen + 3] = (bitLenHi >>>  0) & 0xff;
    padded[paddedLen + 4] = (bitLenLo >>> 24) & 0xff;
    padded[paddedLen + 5] = (bitLenLo >>> 16) & 0xff;
    padded[paddedLen + 6] = (bitLenLo >>>  8) & 0xff;
    padded[paddedLen + 7] = (bitLenLo >>>  0) & 0xff;

    const W = new Uint32Array(64);

    for (let i = 0; i < padded.length; i += 64) {
      for (let t = 0; t < 16; t++) {
        const j = i + t * 4;
        W[t] = ((padded[j] << 24) | (padded[j+1] << 16) | (padded[j+2] << 8) | (padded[j+3])) >>> 0;
      }
      for (let t = 16; t < 64; t++) {
        const s0 = (rotr(7, W[t-15]) ^ rotr(18, W[t-15]) ^ (W[t-15] >>> 3)) >>> 0;
        const s1 = (rotr(17, W[t-2]) ^ rotr(19, W[t-2]) ^ (W[t-2] >>> 10)) >>> 0;
        W[t] = (W[t-16] + s0 + W[t-7] + s1) >>> 0;
      }

      let a=H[0], b=H[1], c=H[2], d=H[3], e=H[4], f=H[5], g=H[6], h=H[7];

      for (let t=0;t<64;t++) {
        const S1 = (rotr(6,e) ^ rotr(11,e) ^ rotr(25,e)) >>> 0;
        const ch = ((e & f) ^ (~e & g)) >>> 0;
        const temp1 = (h + S1 + ch + K[t] + W[t]) >>> 0;
        const S0 = (rotr(2,a) ^ rotr(13,a) ^ rotr(22,a)) >>> 0;
        const maj = ((a & b) ^ (a & c) ^ (b & c)) >>> 0;
        const temp2 = (S0 + maj) >>> 0;

        h=g; g=f; f=e; e=(d + temp1) >>> 0;
        d=c; c=b; b=a; a=(temp1 + temp2) >>> 0;
      }

      H[0]=(H[0]+a)>>>0; H[1]=(H[1]+b)>>>0; H[2]=(H[2]+c)>>>0; H[3]=(H[3]+d)>>>0;
      H[4]=(H[4]+e)>>>0; H[5]=(H[5]+f)>>>0; H[6]=(H[6]+g)>>>0; H[7]=(H[7]+h)>>>0;
    }

    const out = new Uint8Array(32);
    for (let i=0;i<8;i++){
      out[i*4+0]=(H[i]>>>24)&0xff;
      out[i*4+1]=(H[i]>>>16)&0xff;
      out[i*4+2]=(H[i]>>>8)&0xff;
      out[i*4+3]=(H[i]>>>0)&0xff;
    }
    return out;
  }

  function hmacSha256(key, msg) {
    const blockSize = 64;
    let k = key;
    if (k.length > blockSize) k = sha256(k);
    const oKeyPad = new Uint8Array(blockSize);
    const iKeyPad = new Uint8Array(blockSize);
    oKeyPad.fill(0x5c);
    iKeyPad.fill(0x36);
    for (let i=0;i<k.length;i++){
      oKeyPad[i] ^= k[i];
      iKeyPad[i] ^= k[i];
    }
    const inner = new Uint8Array(iKeyPad.length + msg.length);
    inner.set(iKeyPad,0);
    inner.set(msg,iKeyPad.length);
    const innerHash = sha256(inner);

    const outer = new Uint8Array(oKeyPad.length + innerHash.length);
    outer.set(oKeyPad,0);
    outer.set(innerHash,oKeyPad.length);
    return sha256(outer);
  }

  const sigBytes = hmacSha256(keyBytes, msgBytes);
  let binary = "";
  for (let i=0;i<sigBytes.length;i++) binary += String.fromCharCode(sigBytes[i]);
  return btoa(binary).replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,'');
}
    document.getElementById("gen").addEventListener("click", async () => {
      const days = Math.max(1, Math.min(365, Number(document.getElementById("days").value) || 30));
      const note = String(document.getElementById("note").value || "").trim();
      const iat = Date.now();
      const exp = iat + days * 24 * 60 * 60 * 1000;
      const deviceId = String(document.getElementById("deviceId").value || "").trim();
      if (!deviceId) {
        alert("Vul eerst de Activatie-ID in (van tester).");
        return;
      }
      const payload = { iat, exp, note, deviceId };
      const payloadB64Url = base64UrlEncode(JSON.stringify(payload));
      const sigB64Url = await hmacSha256Base64Url(payloadB64Url);
      const token = payloadB64Url + "." + sigB64Url;
      document.getElementById("out").value = token;
    });
  </script>
</body>
</html>
